#! /usr/bin/env ruby

# This action is used to remediate objects in some way that you define.
# You supply a list of druids to remediate in a CSV file and a Ruby file defining a method that operates on the objects.
# The code handles all logging and versioning as needed.

# Run with
# ROBOT_ENVIRONMENT=production bin/remediate CSV_FILE_WITH_DRUIDS.csv REMEDIATE_LOGIC_FILENAME.rb

# CSV_FILE_WITH_DRUIDS has the format of one column with a list of druids -- no other columns should be present. An example is below.
# This file should be in a location where the script has read/write access to it.
#druid:oo000oo0001
#druid:oo000oo0002

# REMEDIATE_LOGIC_FILENAME is a reference to a Ruby code file that defines what you want the remediation to do.  An example of this 
# file is in lib/remediation/remediate_project_example.rb  Copy that file, and edit it somewhere the script can read it and then pass 
# the filename to the script.

# The result will be some screen output, a detailed .YML file in the same location and with the same name as the input CSV file.
# The input CSV file will be updated with two additional columns - a status indicating if remediation succeeded and a message.
# You can re-run remediation with the same CSV file and it will automatically skip already completed objects.

# Note that unless your laptop has access to the Fedora instance you need to remediate (usually Production), 
# you should probably run this from lyberservices-prod to have access to all mounts and configuration.

require File.expand_path(File.dirname(__FILE__) + '/../config/boot')
require 'rubygems'
require 'csv'
require 'pre_assembly/remediation/remediate'

def help(error_msg)
  abort "#{error_msg}\n\nUsage:\n  ROBOT_ENVIRONMENT=XXXXX remediate CSV_FILE_WITH_DRUIDS REMEDIATE_LOGIC_FILENAME\n"
end

help "Incorrect N of arguments." if ARGV.size < 2
csv_in = ARGV[0]
remediate_logic_file = ARGV[1]

help "CSV file not found." unless File.file?(csv_in)
help "REMEDIATE_LOGIC_FILE file not found." unless File.file?(remediate_logic_file)

require remediate_logic_file

source_path=File.dirname(csv_in)
source_name=File.basename(csv_in)
progress_log_file=File.join(source_path,source_name + '_log.yml')
csv_out=File.join(source_path, SecureRandom.hex + '_' + source_name)

# generate output CSV in same location as source CSV; we'll rename and remove original later
csv_file_out = CSV::Writer.generate(File.open(csv_out,'wb'))

# read input CSV
csv_file_in = CSV::Reader.parse(File.open(csv_in))
csv_file_in.each_with_index  do |row, x|
  pid=row[0].to_s.strip
  done = false if row.size == 1  # if there is no second column in the input csv for this row, this must mean it has not been done
  if done || row[1].to_s.strip.downcase=="true"
    puts "#{pid} : skipping, already completed"
    csv_file_out << row
  else
    item=PreAssembly::Remediation::Item.new(pid)
    item.extend(RemediationLogic) # add in our specific methods
    success=item.remediate
    message=success ? item.message : "ERROR : #{item.message}"
    output_row=[pid,success,message] # output csv
    csv_file_out << output_row
    puts "#{pid} : #{success}"    
    File.open(progress_log_file, 'a') { |f| f.puts item.log_info.to_yaml } # complete log to output file
  end
end

csv_file_in.close
csv_file_out.close
 
File.delete(csv_in) # remove the input file
File.rename(csv_out,csv_in) # rename the output to the input file
