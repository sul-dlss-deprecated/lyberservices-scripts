==Pre-assembly

This is a Ruby implementation of services needed to prepare objects to be assembled and then accessioned in SULAIR digital library.

==Version History

1.0.0  Released to production
1.2.0  Changed <provider_checksum> node to regular <checksum> node.  Must be run in combination with assembly 1.2.0.

==Running

1. Gather information about your project, including:
	a. The location of the materials.  You will need read access to this location from the servers you will be accessioning in (e.g. test and production).
	b. Whether the objects are already registered or not.
	c. The location of any descriptive metadata.
	d. Whether you will be flattening the folder structure of each object when accessioning (e.g. discarding any folder structure provided to you in each object).
	e. The DRUID of the project's APO.
	f. The DRUID of the set object you will be associating your objects with (if any).
	g. If your objects are not yet registered and you have a manifest file in CSV format, make sure you have columns for sourceid, filename, and label.  See config/projects/manifest_template/TEMPLATE_manifest.csv for an example manifest.  See the "manifest" section below for more information.
	h. If you are using a manifest file in CSV format and want to create descriptive metadata, create a MODs XML template.  See the "descriptive metadata" section below for more details.
	
2. Create a project-configuration YAML file using the data you gathered above.  Store this file in a location where it can be accessed by the server (test or production).  You should create a YAML file for each environment specifying the parameters as appropriate.  Use the convention of "projectname_environment.yaml", e.g. "revs_test.yaml".  
If you have multiple collections to associate your objects with, you will need to run in multiple batches with multiple YAML files.  You can add your collection name to the end of each YAML filename to keep track (e.g. "revs_test_craig.yaml")

The YAML file can be stored anywhere that is accessible to the server you are running the code on.  However, for simplicity, we recommend you
store the YAML at the root of your bundle directory, or create a new project folder, place your YAML file into it and then place your bundle
directory into your new project folder.

Example:

Your content is on /thumpers/dpgthumper-staing/Hummel
Create a YAML file at /thumpers/dpgthumper-staging/Hummel/hummel_test.yaml
Move your content (if you can) into /thumpers/dpgthumper-staging/Hummel/content

If you cannot move your content, be sure your YAML bundle discovery glob and/or regex are specific enough to correctly ignore your YAML file during discovery.  Or, alternatively, place your YAML file in a location other than the bundle.

   See config/projects/TEMPLATE.yaml for a documented example of a configuration file.
   See config/projects/local_dev_revs.yaml for a specific example using a manifest.
   See config/projects/local_dev_gould.yaml for a specific example using a file system crawl.

3. You will benefit from running some objects in a local or test environment.  If your objects are already registered, this may require pre-registering a sample set in test as well as production using the same DRUIDs that are identified with your content.
You may also have to move a small batch of test content to a location that is visible to sul-lyberservices-test.  Since the thumper drives are not mounted on the test server, you can use the /dor/content mount on test for this purpose.

4. Make sure you have an APO for your object, and that the administrativeMetadata data stream has the <assemblyWF> defined in it.  If it does not, go to https://consul.stanford.edu/display/APO/Home and find the "Current FoXML APO template" link at the bottom of the page.  Download and open the template, find the <assembly> node and copy it.  Go to Fedora admin for each relevant environment (test/production) and this node to the administrativeMetadata stream.  If you don't have this workflow defined in your APO, then the assembly robots will never operate and accessioning will not operate.
This APO should be defined using the same DRUID in test and production if you intend to run in both locations.

5. If you are not using a manifest, perform a dry discovery run which will enumerate the discovered objects and check for filename uniqueness.
This is also important if you are flattening each object's folder structure during pre-assembly (e.g. each object has images in a '00' and '05'
directory, but you don't want to retain those folders when accessioning), since you will want to check to make sure each file in a given object
has unique filenames.

   bin/discovery_report YAML_FILE

You will see a report containing:
a) the total number of objects discovered
b) the names of each discovered object along with the number of files which will be discovered in that object
c) any entries (directories or files) in the bundle directory which will *not* be discovered based on your configuration.
d) the total number and listing of any objects which have duplicate filenames.  You must resolve the duplicate filenames if you intend to flatten the folder structure when accessioning.

6. To run pre-assembly locally:

    # Normal run.  Will restart and crete a new log file, overwriting any existing log file for that project.
    bin/pre-assemble YAML_FILE

    # Run in resume mode, which will automatically pick up where left off based on the log file.
    bin/pre-assemble YAML_FILE --resume

7. Running in the production environment:

    - Navigate to the production box, in the pre-assembly area.
    - Set the ROBOT_ENVIRONMENT.
    - Run pre-assembly with nohup and in the background (&).
    - Optionally, include the --resume option.
	
	See the example below:

    ssh lyberadmin@sul-lyberservices-prod.stanford.edu
    cd /home/lyberadmin/pre-assembly/current
    ROBOT_ENVIRONMENT=production nohup bin/pre-assemble YAML_FILE &

    # Various ways to monitor progress:
    1. The workflow grid in Argo, using your project tag to filter.
    2. grep pid PROGRESS_LOG          # Using the filename defined in YAML progress_log_file.
    3. tail -999f log/production.log  # Detailed logging info for the pre-assembly project itself.
    4. tail -999f nohup.out           # Errors, etc from unix output.

Be sure to keep your progress log file somewhere useful and be aware if you restart pre-assembly without using the --resume switch, it will be overwritten.
You will need the progress log for cleanup and restarting.

==Restarting a job

If you have failed objects during your pre-assembly, these will either cause pre-assembly to terminate immediately (if the failure is non-recoverable)
or it will continue and log the errors.  The progress log file you specified in your YAML configuration will contain information about which bundles failed.
You can re-start pre-assembly and ask it to re-try the failed objects and continue with any other objects that it hadn't done yet.  To do this,
use the --resume flag when you run pre-assembly:

    ROBOT_ENVIRONMENT=production bin/pre-assemble YAML_FILE --resume

==Cleanup

If you need to cleanup accessioned content on test, you can use the progress log file to indicate which objects you would like removed.  

Use the following script to perform a cleanup:

		bin/cleanup YAML_FILE steps
		
where steps is a comma delimited list of any of the following steps defined below:

symlinks == remove symlinks from the /dor/workspace
stage    == removed staged files (typically stored in /dor/assembly, but the specific area is defined as 'staging_dir' in the YAML file)
dor      == remove objects from Fedora
stacks   == remove files from the stacks that were shelved during accessioning ... note this step must be run from a server
(such as sul-lyberservices-test) and you must be able to authenticate to the relevant stacks server

You can also specify the environment using ROBOT_ENVIRONMENT, just as with a pre-assembly run.  Since this script is destructive, you will need
to confirm each step.

For example:

		ROBOT_ENVIRONMENT=test bin/cleanup tmp/revs_log.yaml symlinks,stage,dor

==Other Useful Scripts

There are various useful scripts in the bin directory that can be run with "ROBOT_ENVIRONMENT=xxx bin/SCRIPT_NAME"

Open the scripts up to set the required configuration parameters at the top (and you should probably back them out if you are committing the code again).

* delete_by_druid  -- specify DRUIDs that should be deleted from Fedora (can be done via the cleanup methods above as well if you have a progress log file)
* delete_by_sourceid -- specify source_ids of objects that should be deleted from Fedora
* restart_workflow_steps -- specify DRUIDs or source_ids along with specific workflow steps that should be reset back to 'waiting'
* run_all_tests -- run all spec and integration tests.  Note that for integration tests to run, you need to be on the Stanford network.
* find_workflow_statues -- specify a progress log file and this will tell you if your objects have any errors in the assemblyWF


==Post Accessioning Report

A reporting script is available until full reporting is complete in Argo.  Run it with:

 ./bin/generate_collection_report PROJECT_TAG

where PROJECT_TAG is the Argo project tag (e.g. "Revs").  It will create a CSV in the log/ folder of your checkout pre-assembly code.  It may default to only 100 rows returned.  Check the script.

==Manifests

Manifests are a way of indicating which objects you will be accessioning.  A manifest file is a CSV, UTF-8 encoded file and currently only works for projects that have a single file (e.g. image) per object, since each row in the manifest will become an object.  

There are three required columns in the manifest:

sourceid
filename
label

The first line of the manifest is a header and specifies the column names. Column names should not have spaces and it is easiest if they are all lower case. These columns are used to register objects and indicate which file goes with the object.  The filename is relative to the manifest file itself.  You can have additional columns in your
manifest which can be used to create descriptive metadata for each object.  See the section below for more details on how this works.

A sample manifest file is located in config/projects/manifest_template/TEMPLATE_manifest.csv for an example.  

==Descriptive Metadata

If descriptive metadata is supplied in a source known to common accessioning (currently MDToolkit or Symphony), then no action is required during pre-assembly other than ensuring your DRUIDs and/or barcodes match the ones in MDToolkit or Symphony.

If you are supplying a manifest file instead of using object discovery via file system crawling, then you can also create a descriptive metadata MODs file for each object using content supplied in the manifest.  By creating a template XML MODS file, placing with your YAML configuration file and ensuring it's filename is indicated in your YAML configuration, you can tell pre-assembly to generate a MODs file per object.  The generated MODs file will be called "descriptiveMetadata.xml" and will be staged alongside the content.  This file is automatically picked up during common accessioning.  

The MODs file is generated by taking the XML template you supply, and filling in any [[FIELD]] values in the template with the corresponding column from the manifest.

For example, if your template has

<mods><title>[[description]]</title></mods>

and you have a column called "description" in your manifest and you have a row with a value of "picture of me", you will get that value filled into your template for that specific object:

<mods><title>picture of me</title></mods>

In addition, the entire MODs template is passed through an ERB parser, allowing you to utilize Ruby code in the template using the standard <% %> syntax.  This can be used to peform more complex operations.  If you utilize Ruby code, you will have access to a special local variable called 'manifest_row', which is a hash of values for that row in the manifes, keyed off the column names.  For example:

 <mods><title><%= manifest_row[:description] %></title></mods>
 
will provide the same output as the previous example.  A full example of a MODs template is provided at config/projects/manifest_template/TEMPLATE_mods.xml

==Assembly Robots

The last step of pre-assembly is the initiation of the assembly workflow for a given object.  This assumes the assemblyWF is defined in the APO referenced by the project, and it also assumes the assembly robots are running on the server.  If the assembly robots are not running, then JP2 creation and all follow up steps will not occur.  You can determine if the robots are running on the server with:

ps -ef | grep assemblyWF

If you see only one line, something like below, the assembly robots are  NOT running:
501 26382 26097   0  1:04PM ttys001    0:00.00 grep assemblyWF

If you see multiple lines, something like below, the assembly robots are running:
503        782     1  0 10:25 ?        00:00:04 assemblyWF:jp2-create
503        784     1  0 10:25 ?        00:00:04 assemblyWF:checksum-compute
503        786     1  0 10:25 ?        00:00:07 assemblyWF:checksum-compare
503        789     1  0 10:25 ?        00:00:07 assemblyWF:exif-collect
503        791     1  0 10:25 ?        00:00:10 assemblyWF:accessioning-initiate
503       9009  8909  0 13:05 pts/0    00:00:00 grep assemblyWF

To start the assembly robots, use the following line.  If you are in production substitute "production" for "test" in the robot_environment variable:
	cd /home/lyberadmin/assembly/current; ROBOT_ENVIRONMENT=test ./bin/run_robot start assemblyWF:jp2-create assemblyWF:checksum-compute assemblyWF:checksum-compare assemblyWF:exif-collect assemblyWF:accessioning-initiate

You can track the progress of each assembly robot by inspecting it's log file on the server.  To see the available log files (one for each robot):
	ls /home/lyberadmin/assembly/current/log
	
Tail a file to watch it's output, e.g.
	tail -f /home/lyberadmin/assembly/current/log/jp2-create.log

Or inspect it for a more complete history, e.g.
	less /home/lyberadmin/assembly/current/log/jp2-create.log

More information on the assembly robots is found in the assembly project here:

corn.stanford.edu:/afs/ir/dev/dlss/git/lyberteam/assembly.git

==Deployment

See Capfile.

==Setting up code for local development

    # Clone project.
    git clone `whoami`@corn.stanford.edu:/afs/ir/dev/dlss/git/lyberteam/pre-assembly.git
    cd pre-assembly

    # Set up some stuff not stored in Git.
    mkdir doc log pkg tmp
    RCONF='lyberadmin@lyberservices-dev.stanford.edu:/home/lyberadmin/pre-assembly/config'
    scp -r $RCONF/certs $RCONF/environments config

    # Get needed gems.
    bundle install

    # Confirm that it's working.  Note that for integration tests to work, you will need to be on the Stanford network and kerberos         # authenticated
    bin/run_all_tests 


==Running tests

For local testing, it's easiest to put this in your bash profile:

	export ROBOT_ENVIRONMENT=local

Running tests:

    # All tests.
    bin/run_all_tests

    # Unit tests and integration tests separately.
    bundle exec rspec spec
    bundle exec rspec integration
